## ra-voice-chat
flask 后台，用后台模板渲染出网页。

1. ra-voice 飞书登录
2. caocao-cron 内存泄露
3. shared-trip 接口性能优化
4. RA-Client fix bug;

解决缓存的问题：
在 `/webapps/common/server/api/create_flask_app.py` 中加一个配置：
`app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0` .

### ra-voice-chat
- chat_page_v2 -> `vertc_index.html/vertc_join_room.html`
- chat_page -> `index.html`
- session_api -> POST
- live_video_api -> `monitor.html`
- vertc_event_api -> POST

test
```
- https://xxx/create_chat_v2
    - ?vehicle_id=p6002
    - &ra_session_id=20546
    - &operator_email=xiaobinzhang@pony.ai
    - &created_by=1
```



第一次登录：
1. 前端访问 `/auth/sso?provider=FEILIAN&state=https://www.baidu.com`
2. 后端返回 redirect url: `https://portal.ponyai-cn.com:10443/api/oidc/authorize?redirect_uri=xxx&scope=openid&state=xx`
3. 用户扫飞连登录
4. 前端访问 redirect_uri（即 `/auth/login_with_sso` 接口），返回的 HTTP 里包含了 Set-Cookie 字段。
5. 浏览器会根据 Set-Cookie 字段，记住这个网站的 Cookie，下次请求会自动带上
6. 前端根据 `/auth/login_with_sso` 的返回的 302 网页，重定向到 state（即 https://www.baidu.com）

第二次登录：
1. 后台登录后，浏览器已经有了 `access_token` 和 `refresh_token`；
2. 前端调用 `/auth/refresh_login` 接口，不用参数，因为有 access_token，所以可以直接登录。后端可以拿到 user 信息；
3. 因为第二次登录距离第一次登录已经过了一段时间，所以access_token可能过期了

这个有问题？
FEILIAN_LOGOUT_CALLBACK_URI


AccessToken 和 Id Token
- AccessToken 可以是 JWT，也可以是随机的字符串。