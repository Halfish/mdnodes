深入阅读的参考文献：
- 《Effective C++》、《More Effective C++》， 侯捷译
- 《C++ Primer》，中文第五版
- 《Inside C++ Object Model》，深入C++对象模型
- 《The C++ Programming Language》
- 《STL 源码剖析》，侯捷著

## 面向对象内容

### 面向对象开发的四大特性
* 封装
    * 隐藏细节
* 抽象
    * 实现接口和实现的分离
* 继承
    * 继承代表了 is-a 关系，如狗是哺乳动物，哺乳动物是动物等
    * 一般是基类（base-class）继承派生类（derived-class），或者成父类和子类
    * 派生类可以继承多个基类
    * C++11 新增关键字 final，来定义一个类不能被继承，如 class Base final {};
* 多态
    * 同一个基类有不同的派生类，这些派生类表现出不同的形态，称为多态。C++通过继承和虚函数来实现多态。
    * 虚函数：
        * 在基类中用 virtual 声明的函数叫虚函数，如 virtual int area() {return _area;}
        * 在派生类中重新定义该虚函数时，编译器不会静态链接到基类的这个函数
        * 注意：子类在重写虚函数时，可以加上 virtual 关键字，也可以不加，但是不加的话编译器会有警告。
    * 纯虚函数：
        * 在基类中只是声明但是不实现的虚函数叫做纯虚函数，如 virtual int area() = 0;
        * 有纯虚函数的类是抽象类，不能被实例化
        * 继承于抽象类的子类必须重写（overwrite）这个纯虚函数，以实现多态，否则子类仍然是抽象类，无法被实例化。
    * 抽象类（ABC，Abstractive Class）
        * 至少含有一个函数是纯虚函数的类是抽象类。
        * 抽象类不能被实例化，只能当做接口用；对应可以被实例化的类叫做是具体类。比如基类是 Animal，派生类是老虎，猴子等，显然 Animal 不适合构建对象，就可以定义为抽象类。
        * 【编程规范】【强制】派生类不允许覆盖基类中的非虚函数。
        * 【编程规范】【强制】若类定义了虚函数，必须定义虚析构函数。
    * 动态绑定/延迟绑定 Dynamic/Late Binding
        * 把一个子类对象赋值给父类对象，父类对象仍然会去调用子类的函数；
        * 静态绑定就是把函数和函数的代码绑定，这个一般链接的时候已经确定了，即函数的跳转地址。
        * 动态绑定是为了实现多态，子类如果实现了父类的虚函数，父类的对象可能会去调用子类的虚函数。


### 虚函数实现原理
* 参考：https://www.cnblogs.com/sylar5/p/11475246.html
* 虚函数表和虚表指针
    * 虚函数表，vtbl，virtual function table，类专有的一个表，可以看做是一个数组，存放所有的虚函数地址。每个类都有一个虚函数表，子类会继承父类的虚函数表（有重写或者新增的虚函数也会更新）。
    * 虚表指针，vptr，virtual table pointer，每个类对象都有一个隐藏的虚表指针，由编译器自动添加，虚表指针指向虚函数表。一般编译器会把虚表放在类存储的开头，方便查找。
* 如果是多重继承，子类的虚函数表用二维数组来存储；
* 构造函数能是虚函数吗？
    * 不行，因为执行构造函数之前还没有分配内存，根本没有虚函数表。
* 析构函数可以是虚函数吗？
    * 可以，且必须是虚函数。因为当释放基类的内存时，如果不是虚函数，子类的析构函数不会被调用。如果基类的析构函数是虚函数，就会调用子类的析构函数，这样内存释放比较完整。

### 友元函数、友元类
* 可以定义友元函数和友元类，运行这些函数或者类访问当前类的私有成员变量或函数
* 加上关键词 friend 即可
* 【编程规范】【建议】
    * 不是非常必要的话，避免使用友元；
    * 友元破坏了类的封装性，增加了类之间的耦合，因此应该避免使用。
    * 友元类的例子，容器和对应的迭代器

### 构造函数
* 初始化
    * 可以这样写： A(): a(aa), b(bb) {}
    * 变量初始化的顺序是根据变量定义的顺序来的
* explicit 关键字修饰的构造函数必须要显式调用；
    * 这样隐式转换就无法调用，而是直接编译错误，这样可以避免一些错误。
    * 如果没有默认的（拷贝）构造函数，编译器会自己给我们构建一个，把成员变量里的值一一复制，可能会发生错误。
    * 比如如果定义了 explicit A(int a)，就不能通过 A aa = 10; 这样来初始化。
* 复制（拷贝）构造函数 A(const A &other) 
    * 函数的值传递或者返回该类型变量时，会调用拷贝构造函数
    * 要用引用传递参数，如果是值传递，则会循环调用自己造成栈溢出；因此在 GCC/VIsual C++ 中会直接编译出错。
    * 默认是浅拷贝，如果成员变量里含有指针，只会复制指针，这样两个指针会指向同一块地址
    * 可以考虑把拷贝构造函数声明为 private
    * 可重载（overload）：即拷贝构造函数可以有多个，只要函数签名（function signature）不同即可，即函数的参数个数或者类型的不同。
* 移动构造函数
    * 设计对象的赋值操作，如果是浅拷贝，可能会有内存泄露的问题，需要定义深拷贝。
    * 但是也有这样的应用场景，就是对象 a 赋值给 b 之后，a 的内存可以不用，就直接置空指针即可，这个就是移动构造函数的特性。
    * 可以用 utility 里定义的 std::move 函数来移动对象
        * int &&rr3 = std::move(rr1);  // 这里的 && 是右值引用，表示 rr1 的原来的值会被销毁。

### 类的拷贝、赋值与析构
* C++ primer 给出两条注意点：
    * 1. 需要析构函数的类也需要拷贝和赋值操作，否则容易出错。
    * 2. 需要拷贝的类也需要赋值操作，反之亦然。（但是不一定需要析构函数）
* Sale_data() = default; 这里的 = default 符号要求编译器显示地合成。
* 可拷贝的类与可移动的类
    * 如果类可以拷贝，一定要同时定义①拷贝构造函数和②赋值构造函数
    * 如果类可以移动，一定要同时定义①移动构造函数和②移动赋值函数
* 如何避免类的拷贝与赋值操作？
    * 如果不定义拷贝构造函数和赋值运算符，编译器会默认构造。
    * 可以用 = delete 关键词来定义删除的函数。以此来阻止拷贝与赋值
        * `NoCopy() = default;`                  // 显示定义默认的合成构造函数
        * `NoCopy(const NoCopy &) = delete;`    // 阻止拷贝构造函数
        * `NoCopy& operator = (const NoCopy &) = delete;`    // 阻止赋值构造函数
        * `~NoCopy() = default;`               // 使用合成的析构函数
    * 也可以把拷贝构造函数和赋值函数定义成私有的来阻止拷贝与赋值
    ```c++
    class PrivateCopy {
            PrivateCopy(const PrivateCopy &) // 这个拷贝构造函数的私有的，外部无法调用。
            PrivateCopy& operator = (const PrivateCopy &); // 同上
        public:
            PrivateCopy() = default;
            ~PrivateCopy() = default;
    }
    ```
    * 注意到上面的拷贝和赋值函数都是私有的，那么外部是无法无法访问的；为了进一步阻止友元类和成员函数调用拷贝和赋值，这里只声明但是不定义。
* 用宏禁止类的复制
    * 没有复制意义的类必须用 DISALLOW_COPY_AND_ASSIGN 宏禁止拷贝构造函数和赋值构造函数。
    * 宏的用法如下：
```c++
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
        TypeName(const TypeName&); \
        TypeName& operator=(const TypeName&)
 
class Foo {
public:
    explicit Foo(int f);
    ~Foo();
private:
    DISALLOW_COPY_AND_ASSIGN(Foo);
};
```

### 重载运算符
* 重载 + 运算符：
    * `String& operator+ (String &str);`
* 重载输入运算符 >>，重载输出运算符 <<
    * `ostream& operator<< (ostream& os, const Sales_data &item) {}`
    * `istream& operator>> (istream &is, Sales_data &item) {}`
