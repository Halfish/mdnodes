redis 分布式锁

参考：[分布式锁的实现之 redis 篇
](https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/)

### 设置锁

redis 命令
- 加锁操作：`SETNX key value`
    - 通过设置 redis 中的某个 key 来实现加锁。
    - SETNX = set key if not exist
- 解锁操作：`DEL key`
    - 通过删除某个键值实现解锁
- 设置超时：`EXPIRE key timeout`
    - 通过设置超时避免资源永远被占用

但是上面的操作有些问题，SETNX 和 EXPIRE 是两个操作，不是原子性。如果后者没有执行会造成资源死锁。

不过现在 redis >= 2.6.12 已经支持设置键值的同时设置超时时间，这个问题已经不存在了。

### 锁的误解除

想象下这个场景：
1. A、B 同用一个资源
2. A 先加锁，但是超时后琐失效，此时 A 仍然没有完成业务。
3. B 看到没有锁，认为资源已经释放，会加锁并执行业务
4. A 执行完业务，会对解锁释放资源。
5. B 执行完任务想解锁，发现锁已经被 A 解除了，一脸懵逼。

总结来说，就是两个程序用了同一个资源，可能会产生锁的误接触。当业务逻辑的时间不超过设定的超时时间就不会有问题，但是生产环境很难保证。

解决方案是给每个程序加一个标识符，比如 UUID 标识。解锁加锁都知道是不是自己的锁。

### 超时解锁导致并发
还是刚刚的场景，刚刚只讨论了不会误解锁。但是中间有段时间，超时导致了两个程序并发执行，这是不被允许的。

有两种解决方案
1. 设置足够长的时间，确保业务逻辑能够完成
2. 为获取锁的线程增加守护线程，为将要过期但是没有释放的锁增加有效时间。

但是感觉两个方案都不是很理想，总不能永远卡死资源吧。

### 不可重入
如果一个锁支持多次加锁，就是可重入的，否则是不可重入的。

Redis 可以对锁进行重入计数，加锁时 +1, 解锁时 -1, 计数为 0 时释放锁。

### 无法等待锁释放

客户端在等待锁时都是立即返回的，可以用下面的方式等待
1. 轮询
    - 当没有获取锁时，等待后再次尝试获取，直到超时。这种方式比较消耗服务器资源。
2. 发布/订阅
    - 当获取锁失败时，订阅锁释放的消息。
    - 释放锁时，发布锁的释放消息。


### 分布式 Redlock

redisson 是 java 的 redis 客户端之一，提供一些 API 方便操纵 redis；

redlock 直接翻译过来是红锁，是 redis 官方提出来的一种算法。Redisson 有提供该方法的实现。
