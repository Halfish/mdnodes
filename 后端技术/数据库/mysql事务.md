# MySQL 事务

通过 `show engines` 命令可以看到，只有 `InnoDB` 支持事务。

## 1. 事务的 ACID 特性

MySQL 事务的ACID特性：
1. `Atomic`，原子性，事务是最小的执行单位，不可分割。要么执行成功，要么失败回滚。
2. `Consistency`，一致性，事务执行前后，数据始终保持合法状态。如A转出的钱=B收到的钱。
3. `Isolation`，隔离性，并发的不同独立之间是独立的，不会相互干扰。
4. `Durability`，持久性，数据库发生故障可以通过日志来恢复。

## 2. 并发带来的问题

假设一个事务在写数据，另一个事务在读同一份数据，此时由于并发，可能会发生一些意想不到的情况。

### 2.1 脏读（Dirty Read）
事务 A 读取了事务 B 已经更新但是没有提交的数据，如果事务 B 回滚，事务 A 读取的数据内容是临时而且无效的。此时意味着发生了脏读。

### 2.2 不可重复读（Non-Repeatable Read）
事务 A 两次读取了某个字段，但是中间被事务 B 修改了，导致两次读取的数据不一样。

### 2.3 幻读（Phantom）
事务 A 两次读取了某个表，但是中间被事务 B 插入或者删除了一些行，导致两次读取的行数不一样。

## 事务的隔离级别

上面的情况可以设置不同级别的隔离性来避免，可以上面的几个问题排个序
- 按照隔离级别：`脏读 < 不可重复读 < 幻读`
- 按照严重程度：反过来。`脏读 > 不可重复读 > 幻读`

所以事情就好办了，脏读影响最坏（因为读了不存在的值），但是只需要很小的隔离级别，即牺牲最少得并发性能，就能得到解决。

`SQL标准` 设置了 4 个隔离级别：
1. `READ UNCOMMITED`，读未提交。
    - 没有解决任何问题，脏读、不可重复读、幻读的问题都存在。
    - 并发性能最高。
2. `READ COMMITED` 读已提交。
    - 解决了脏读的问题，小小牺牲并发性能。
    - 不可重复读、幻读的问题仍然存在。
3. `REPEATABLE READ` 可重复读
    - 解决了重复读的问题。幻读的问题仍然存在。
    - `MySQL` 的 `InnoDB` 引擎默认的隔离级别。
4. `SERIALIABLE` 序列化
    - 不同的事务是串行执行的。完全牺牲了并发。
    - 可以解决幻读的问题。

MySQL InnoDB 引擎的默认隔离级别虽然是【可重复读】，但是其实很大程度上避免了幻读现象
1. 如果是快照读（普通的select语句），通过 MVCC 方式解决了部分幻读。事务执行过程中看到的数据始终不变。
2. 如果是当前读（select...for update 等语句），通过 next-key lock（记录锁+间隙锁, Record Lock + Gap Lock）组合锁彻底解决了幻读，此时插入/删除/修改数据的事务必须阻塞。

注意 for update 加锁
- 如果只是对一条数据修改，只是对这条数据加行锁（record lock）
- 如果是范围查询，还会对整个表价间隙锁（gap lock），防止其他事务对锁定范围的记录进行插入）

## MVCC (Multi-Version Concurrency Control) 多版本并发控制
每次对数据的修改操作（添加、删除、修改），都会生成一个新的数据版本，同时保留旧版本的数据（其实是通过撤销日志来恢复旧版本数据，不会真的存储多份，类似 git diff 算法）。

MVCC 通过版本号和时间戳来决定每个事务可以看到的数据版本。

MySQL 默认的【可重复读】隔离级别，通过 MVCC 机制 + 手动加 next-key 锁，有效解决了可重复读和幻读的问题。

## 事务日志

有两种日志
- `Redo Log`，重做日志，用于保证事务的**持久性**。就是记录事务的具体操作。
- `Undo Log`，回滚日志，回滚到某个特定版本，用于保证事务的**原子性**。

### Redo 日志

InnoDB 存储引擎是以数据页为单位来管理存储空间的，
- 读数据：读取硬盘上的数据页，加载到内存的 Buffer Pool 中，然后 InnoDB 再去访问具体的数据。
- 写数据：InnoDB 修改了数据，先缓存到 Buffer Pool 中，称为脏页，定期刷到磁盘中（checkPoint机制）。

如果脏页来不及刷到硬盘中，便无法保证持久性，因此需要记录下具体地操作，此时 Redo 日志应运而生。

InnoDB 引擎的事务采用了 WAL 技术（Write-Ahead Logging），先写日志，在写磁盘。只有写日志成功了，事务才算成功。如果刷磁盘时宕机了，重启后可以通过 Redo 日志来恢复数据。保证了事务的持久性。

Redo Log 也不是一步刷新到硬盘中的，有 redo log buffer 做一步缓冲。

### Undo 日志
事务更新数据的一个前置操作是先写入一个 Undo 日志记录，以便在事务执行失败后能够回滚。
- 查询操作，不生成回滚日志；
- 插入操作，生成一条删除操作日志；
- 删除操作，生成一条插入日志；
- 修改操作，生成一条修改回旧值的日志。

InnoDB 中的 MVCC 是通过 undo 日志来实现的。

注意 Undo 日志是逻辑日志，不需要持久化到硬盘里，也就更不需要 undo log buffer 了。

## Buffer Pool

mysql 向操作系统申请的连续内存空间，用来存储数据页，作为读写数据的缓存空间。

## 锁
锁可以用来保证事务的隔离性。

### 按照操作类型划分
- 读锁/共享锁（Shared Lock，S Lock）
    - 多个事务一起读，不会相互影响，相互不阻塞
- 写锁/排他锁（Exclusive Lock，X Lock）
    - 同一个时间段，只能有一个事务执行**读取**或者写入

InnoDB 的读写锁可以加载表上，也可以加在行数据上。

```sql
-- S 锁
SELECT  ... LOCK IN SHARED MODE;
-- MySQL 8.0 语法
SELECT ... SHARED MODE;

-- X 锁
SELECT ... FOR UPDATE;
```

在 MySQL 5.7 以及之前的版本，如果获取不到锁，就会一直等待，直到 `innodb_lock_wait_timeout` 超时。

MySQL 8.0 之后，可以通过一些关键词定义一些行为：
- `NOWAIT`，立马返回，且报错；
- `SKIP LOCKED` 立马返回，跳过锁定的行。


### 按照粒度划分

#### 1. 表级锁

表级锁
- 表级锁不依赖于存储引擎，不会有死锁的问题，开销最小但是对并发影响最大。
- `LOCK TABLES t READ`: InnoDB 存储引擎会对表 `t` 加表级别的 `S锁`
    - 自己可读不可写，他人可读不可写
- `LOCK TABLES t WRITE`: InnoDB 存储引擎会对表 `t` 加表级别的 `X锁`
    - 自己可读可写，他人不可读也不可写
- 不建议加表级别的锁

```sql
-- 查看表级别的锁的详情
show open tables;

-- 加读锁
lock tables mytable read;

-- 解除锁
unlock tables;
```

其他的表级锁
- 意向锁（intention Lock）
    - 比如已经加了行锁，InnoDB会**自动**给更大一级的空间（如页和表）加一个意向锁
    - 意向锁不会真的锁定，只是其他事务想加页锁或表锁时，会先看看有没有意向锁，有的话会阻塞，只是为了优化性能。
    - 具体分意向共享锁（IS），意向排他所（IX）
- 自增锁（AUTO-INC锁）
    - 多个事务插入数据的时候，获取主键的自增值是加锁的，而且是表级别的锁
- 元数据锁（Metadata Lock，MDL）
    - 变更表时，需要加锁
    - 分 MDL 读锁和写锁

#### 2. 页级锁
当行级锁的存储空间不够，会自动升级为表锁。

#### 3. 行锁
行锁（Row Lock）也叫作记录锁，行锁是在 InnoDB 存储引擎层实现的。其中共享锁和排他锁和之前讲过的规则一样。

间隙锁（Gap Lock），即对修改的SQL加锁。不允许修改范围内的数据。主要是为了防止幻读。

临键锁（Next key Lock） = 行锁 + 间隙锁
- 行锁只能给某条数据加锁
- 间隙锁是对某个开区间 `(begin, end)`范围加锁
- 临键锁范围更灵活 `[begin, end)`

### 按照态度
悲观锁和乐观锁是两种实现并发的思想。

悲观锁比较简单，就是发生数据竞争是一定会加锁。悲观的认为其他的事务一定会修改数据。

乐观锁则是乐观的认为其他事务大概率不会修改数据。
- 乐观锁实现有 CAS 和版本号两种方法。
- 版本号方案：每次修改后要增加版本号，查看版本号有没有变化；有变化的失败重试。
- CAS（Compare-And-Swap，比较并交换）基于比较的方法，不用加锁，CPU级别支持原子操作。

悲观锁用于多写场景，乐观锁用于多读场景。

### 加锁方式
显示锁、隐式锁


隐式锁
- 新插入的一条数据，需要加入一条隐式锁，防止有事务会读取到这条数据，不然会有脏读的问题。

显式锁：正常显示加锁的情况

### 其他
全局锁：对整个数据库加锁，只能读，不能改。比如在逻辑备份的时候需要加全局锁。

```sql
Flush tables with read lock;
```

死锁：两个线程获取两个资源，各自不释放。

自旋锁（spinlock）：等待资源的时候，循环查看锁是否释放，短期内可能会拿到数据。
- 优点：不用线程切换
- 缺点：可能会导致CPU空转。
