# MySQL 事务

通过 `show engines` 命令可以看到，只有 `InnoDB` 支持事务。

## 1. 事务的 ACID 特性

MySQL 事务的ACID特性：
1. `Atomic`，原子性，事务是最小的执行单位，不可分割。要么执行成功，要么失败回滚。
2. `Consistency`，一致性，事务执行前后，数据始终保持合法状态。如A转出的钱=B收到的钱。
3. `Isolation`，隔离性，并发的不同独立之间是独立的，不会相互干扰。
4. `Durability`，持久性，数据库发生故障可以通过日志来恢复。

## 2. 并发带来的问题

假设一个事务在写数据，另一个事务在读同一份数据，此时由于并发，可能会发生一些意想不到的情况。

### 2.1 脏读（Dirty Read）
事务 A 读取了事务 B 已经更新但是没有提交的数据，如果事务 B 回滚，事务 A 读取的数据内容是临时而且无效的。此时意味着发生了脏读。

### 2.2 不可重复读（Non-Repeatable Read）
事务 A 两次读取了某个字段，但是中间被事务 B 修改了，导致两次读取的数据不一样。

### 2.3 幻读（Phantom）
事务 A 两次读取了某个表，但是中间被事务 B 插入或者删除了一些行，导致两次读取的行数不一样。

## 事务的隔离级别

上面的情况可以设置不同级别的隔离性来避免，可以上面的几个问题排个序
- 按照隔离级别：`脏读 < 不可重复读 < 幻读`
- 按照严重程度：反过来。`脏读 > 不可重复读 > 幻读`

所以事情就好办了，脏读影响最坏（因为读了不存在的值），但是只需要很小的隔离级别，即牺牲最少得并发性能，就能得到解决。

`SQL标准` 设置了 4 个隔离级别：
1. `READ UNCOMMITED`，读未提交。
    - 没有解决任何问题，脏读、不可重复读、幻读的问题都存在。
    - 并发性能最高。
2. `READ COMMITED` 读已提交。
    - 解决了脏读的问题，小小牺牲并发性能。
    - 不可重复读、幻读的问题仍然存在。
3. `REPEATABLE READ` 可重复读
    - 解决了重复读的问题。幻读的问题仍然存在。
    - `MySQL` 的 `InnoDB` 引擎默认的隔离级别。
4. `SERIALIABLE` 序列化
    - 不同的事务是串行执行的。完全牺牲了并发。
    - 可以解决幻读的问题。

MySQL InnoDB 引擎的默认隔离级别虽然是【可重复读】，但是其实很大程度上避免了幻读现象
1. 如果是快照读（普通的select语句），通过 MVCC 方式解决了部分幻读。事务执行过程中看到的数据始终不变。
2. 如果是当前读（select...for update 等语句），通过 next-key lock（记录锁+间隙锁, Record Lock + Gap Lock）组合锁彻底解决了幻读，此时插入/删除/修改数据的事务必须阻塞。

注意 for update 加锁
- 如果只是对一条数据修改，只是对这条数据加行锁（record lock）
- 如果是范围查询，还会对整个表价间隙锁（gap lock），防止其他事务对锁定范围的记录进行插入）

## MVCC (Multi-Version Concurrency Control) 多版本并发控制
每次对数据的修改操作（添加、删除、修改），都会生成一个新的数据版本，同时保留旧版本的数据（其实是通过撤销日志来恢复旧版本数据，不会真的存储多份，类似 git diff 算法）。

MVCC 通过版本号和时间戳来决定每个事务可以看到的数据版本。

MySQL 默认的【可重复读】隔离级别，通过 MVCC 机制 + 手动加 next-key 锁，有效解决了可重复读和幻读的问题。

## 锁