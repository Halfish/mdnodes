
消息队列（MQ，Message Queue）是分布式系统中重要的组件，主要的应用场景是
> 当不需要立即获取结果，但是并发量又需要控制的时候，需要使用消息队列

### 1. 常见的消息队列（MQ，Message Queue）
- [Python-RQ](https://python-rq.org/)
    - 基于 Redis 实现的一个简单的消息队列库。是一个消费者生产者模型。
    - 通过存储要执行的函数以及参数，去执行一个个任务。
- [RabbitMQ](https://www.rabbitmq.com/)
    - RabbitMQ 在 2007 年发布，基于 AMQP 基础上完成，是当前最主流的消息中间件之一；
    - 基于 erlang 语言开发，性能好，社区活跃度高
    - 需要学习比较复杂的接口和协议，学习和维护的成本高
- ActiveMQ
    - ActiveMQ 是由 Apache 出品，符合 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。
    - 基于 Java 开发，需要 Java JDK，社区活跃度高
- Kafka
    - 是一个**分布式**消息发布订阅系统。最初由 LinkedIn 公司实现的一个提交日志系统（a distributed commit log），之后成为 Apache 项目的一部分。
    - 基于 Java 开发，客户端支持多种语言
    - Kafka的优点在于 1. 分布式，可以支持更大的并发业务。2. 消息有持久化，可以重试。 3. 支持事务。
    - Kafka 为了支持分布式，做了很多工作。如怎么保证数据的可靠性，发布和订阅的时延。
- RocketMQ
    - 阿里公司的开源产品，用 Java 实现，设计时参考了 Kafka，可靠性能好。
    - 支持非常大规模的队列
    - 目前只支持 Java 和 C++，而且后者也不成熟。

### 2. 消息队列的应用场景
- 应用解耦
    - 比如上传人脸的系统和人脸识别系统，可以通过消费者生产者模型来解耦。用消息队列来上传图片和传递结果。
    - 没有消息队列时，两个系统只能耦合在一起，缺点是费时、等待，还得重试。
- 异步处理
    - 可以把能并行处理的操作，用消息队列做并行处理，但是不用做多线程或者多进程。
    - 比如同时发送注册邮件和注册短信。
- 限流削峰
    - 后端瞬时访问量过大，会导致流量暴增，相关系统无法处理造成系统崩溃。
    - 用消息队列相当于做了一次缓冲，业务系统可以选择只读取自己的能力范围内的并发量
    - 队列长度可以做限制，后入队列的用户无法秒杀到商品。
- 消息驱动
    - 可以选择立即处理，也可以选择延时处理，或者定时处理。
- 业务的健壮性
    - 消息队列可以堆积请求，所以消费端即使短时间挂了，也不影响业务的正常进行。
- 冗余性
    - 一个发布者发布消息，可以被多个订阅者订阅。

### 3. 消息队列的两种模式
1. 点对点模式
    - 有三个角色：消息队列、生产者（producer）、消费者（consumer）
    - 生产者产生消息到消息队列中，消费者从消息队列中取出消息，消费后删除。
2. 发布/订阅模式
    - 有三个角色：主题、发布者（publisher）、订阅者（subscriber）
    - 发布者和订阅者通过主题来保持联系，时间上有依赖性
    - 订阅者必须保持在线运行

Kafka 通过 topic 来支持点对点模式，相当于消息队列。同时通过 consumers 组来支持发布和订阅。

### 4. 使用消息队列的缺点
- 系统复杂性
    - 引入了新系统，系统变复杂了。
    - 消息队列会有消息重复、消息丢失、消息是顺序消费的问题。
- 数据一致性
    - 由于解耦和异步性，上游无法感知下游的成功与否，于是无法保证数据的一致性。
    - 可以用分布式事务，把所有的步骤放在一个事务里，要么全部成功，要么全部失败。
