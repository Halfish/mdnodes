# 索引（Index）
什么是索引？索引是**关系数据库**中对某一列或多个列的值进行**预排序**的数据结构，一般是用 `B/B+` 树这样的结构。树的节点由 key，value 对组成，key 是已排序的索引列，value 是指向数据行的指针。

没有索引的查找必须进行全表扫描，速度非常慢。

索引能够加快数据检索的速度，但是因为要维护索引的数据结构，也会带来修改数据库（插入、修改、删除）的性能损失，而且存储索引还要消耗磁盘空间。

下面是一些创建所以的 SQL 语句示例。
```sql
# 创建索引
ALTER TABLE students ADD INDEX idx_score (score);
ALTER TABLE students ADD INDEX idx_name_score (name, score);

# 创建唯一索引，以约束该列的唯一性
ALTER TABLE students ADD UNIQUE INDEX uni_name (name);
# 仅创建唯一约束，而不创建索引
ALTER TABLE students ADD CONSTRAINT uni_name UNIQUE (name);
```

## 一个简单的索引设计方案
MySQL 中的数据是存储在数据页中的，每个数据页是16KB，可以存储很多行数据。这是为了避免频繁读取磁盘。

不同的数据页之间，用双向链表连接，同一个数据页内，不同的数据记录用单向链表连接。所有的行数据严格按照主键排序。


## 聚簇索引 (Clustered Index)
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，也就是所谓的索引即数据，数据即索引。

聚簇指的是就是相邻数据行存储在一起，即存储在页表里。一个表只能有一个聚簇索引，是按照主键值的大小进行记录和页的排序。

特点：
1. 使用表的主键值的大小进行数据行和数据页的排序；
2. B+树的叶子节点存储的是完整的用户记录；
3. 聚簇索引不需要用户创建，InnoDB 会自动创建聚簇索引。

优点：
- 访问速度快，二分查找，特别是排序查找和二分查找
- B+树可以方非常多的数据，节省了大量的IO操作。

缺点：
- 插入速度严重依赖插入顺序，按照主键插入是最快的，否则需要进行页分裂，会影响性能。
- 更新主键的代价很高，一般定义主键不可更新。
- 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键找到行数据。

关于主键：
- 每个表只能有一个聚簇索引，一般情况就是按照主键来建立聚簇索引。
- 如果没有主键，会选择非空的唯一索引，如果没有这样的索引，InnoDB会定义一个主键来做为聚簇索引。
- 不要用 UUID，MD5 这种无序的 ID 作为主键，否则不是顺序插入数据会影响性能。
- 建议用默认的自增ID作为主键，或者分布式的雪花算法（snowflake算法）。

## 非聚簇索引 (Nonclustered Index)
又叫二级索引、辅助索引，一般用于非主键的查找，构建的 B+ 树的叶子节点不会存放完整的数据行，而是特定的列值。

**回表**
非聚簇索引查找到的结果是列值和主键值，需要再去聚簇索引里找到具体的数据行，这个过程叫做回表操作。

## 联合索引

联合索引其实也是一种非聚簇索引，但是需要单独拿出来讲一下。
- 联合索引是给多个列（>=2）建立索引
- 底层比较顺序时，依次按照每个列去比较。举个例子，第一个列相同时，再去比较第二个列。
- B+树的叶子节点存储多个列 + 主键列的值

## B+树
上面的章节已经讲了B+树的概念，但是有些需要注意的点：
- 根页面的位置永远不动：B+树是自顶向下扩展节点
- 非叶子节点中目录项记录的唯一性，即非叶子节点也要带着主键的值，以确保唯一性
- 一个数据页至少存放两条记录

B-Tree 就是 B树，而 B+ 树是 B 树的一种变体，也是一种具体的应用。没有 B- 树这种东西
- B+树的所有数据都存在叶子节点中，而B树的非叶子节点也可以存数据。
- B+树的结构适合做范围查找，而B树做不到
- B树的非叶子节点也要存放数据，所以子节点的个数会少于B+树，导致树的高度偏大，对I/O不友好。

## R树
用来存储地理数据，即坐标数据。可以解决高维空间搜索问题。

## 索引失效

最左匹配原则
