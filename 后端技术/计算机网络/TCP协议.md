## TCP 协议


### 三次握手（建立连接）

<img src="./../../img/TCP三次握手.drawio.webp" width=600 />

TCP 建立连接需要经过三次握手：
1. 第一次握手：客户端发送 `SYN=1` 和 `Seq Num` 给服务端；
2. 第二次握手：服务端收到后，发送 `SYN=1, ACK=1` 和 `seq_num+1` 和 `ack_num`；
3. 第三次握手：客户端发送 `ACK=1` 和 `ack_num+1` 给服务端。


为什么需要第三次握手：
1. （主要原因）防止旧的客户端连接请求建立无效的连接，即第一次握手可能发出多个包。
2. 第三次握手发送了 `ack_num+1`，表示客户端也可以收数据。
3. 如果第二次握手就开始建立连接，会浪费很多资源在无效的连接上。

http 1.1 中引入了持久连接（keep alive），可以持续使用 TCP 进行通信。

### 四次挥手

<img src="./../../img/tcp_disconnect.png" width=600 />

TCP 断开连接需要经过四次挥手：
1. 第一次挥手：客户端（也可以是服务端主动断开）请求断开连接，发送 `FIN=1` 给服务端。
2. 第二次挥手：服务端收到后，发送 `ACK=1` 给客户端。
3. 第三次挥手：服务端继续发送 `FIN=1` 给客户端。
4. 第四次挥手：客户端收到后，发送 `ACK=1` 给服务端

为什么需要四次握手？
- 双方都需要告诉对方自己停止发送数据了，因此都需要传 `FIN=1` 给对方。
- 第四次握手，是因为服务端需要确保消息被收到，否则需要超时重传。

当服务端大量出现 `TIME_WAIT` 状态的连接时，可能是因为什么？
1. 可能是因为客户端或者服务端其中的一个没有开启长连接 `Connection: Keep Alive`
    - 无论哪方禁用了长连接，都是服务端主动关闭连接。
2. 长连接超时
    - HTTP 长连接如果超时，即60s内没有收到新的数据，就会主动断开连接。
    - 可以排查下是不是网络问题，所以才长时间没有收到客户端的消息
3. 长连接请求数量达到上限制
    - 长连接存在的时间太长，处理了太多的请求，该退休了。
    - 可以调大 nginx 的 keepalive_requests 参数来缓解，默认100不够用。

### 拥塞控制
